
1.分布式系统

P.S
	传统系统:  图书管理系统: 用户模块:登陆注册   管理员模块:  图书借阅管理:
	分布式系统:一个业务拆分成多个子业务，部署在不同的服务器上，通过一定的通信协议，能够让这些子业务之间相互通信
问题；各个子模块之间沟通交流协作的问题

CAP理论:
	一致性（Consistency）   强|关系型数据库      弱|容忍那么小华读取的时候是V0   最终|如果经过一段时间后要求能访问到更新后的数据
	可用性（Availability）
	分区容错性（Partition tolerance）
	
	
	满足CA舍弃P，也就是满足一致性和可用性，舍弃容错性  不是分布式系统了
	满足CP舍弃A，也就是满足一致性和容错性，舍弃可用性。如果你的系统允许有段时间的访问失效等问题，这个是可以满足的
	满足AP舍弃C，也就是满足可用性和容错性，舍弃一致性。这也就是意味着你的系统在并发访问的时候可能会出现数据不一致的情况。			 
				 
	淘宝 12306一般牺牲一致性  你填信息的时候  （牺牲的是强一致性，保证最终一致性）
*******************************

2.双亲委派
	1.类加载过程：
		加载: 到字节流，然后将其加载到 JVM 中，生成类对象
		链接: 生成的类对象融入到 JVM
			验证 ->检验一下加载的类是否满足 JVM 的约束条件，也就是判断是否合规
			准备 ->加载类的静态变量申请内存空间，并赋予初始值
			解析 ->符号引用解析成为实际引用
		初始化:常量字段赋值然后执行静态代码块
		
		
		
		
	BootstrapClassLoader:启动类加载器：属于虚拟机自身的一部分，用 C++ 实现:<JAVA_HOME>\lib目录中或被 -Xbootclasspath 指定的路径中
	ExtentionClassLoader:扩展类加载器    独立于虚拟机          java实现   :<JAVA_HOME>\lib\ext或被java.ext.dirs 系统变量所指定的路径的类库
	ApplicaitonClasssLoader              独立于虚拟机          Java实现    :用户类路径(classPath)上的类库
	自定义classloader
	
	加载器之间的关系不是继承 而是组合
	
	流程:子类加载器先让父类加载器去加载，直到父类加载器没找到，再让子类去加载
	三次破坏:
		第一次: jdk 1.2 之前时候还没有双亲委派模型 ，重写 loadClass 方法来实现用户自定义类加载器
				1.2 的时候要引入双亲委派模型，为了向前兼容， loadClass 这个方法还得保留着使之得以重写，新搞了个 findClass 方法让用户去重写，并呼吁大家不要重写 loadClass 只要重写 findClass
		第二次：JNDI、JDBC
			SPI(Service Provider Interface)，它是面向拓展的 我定义了个规矩，就是 SPI ，具体如何实现由扩展者实现
	
	
		第三次:  OSGI 就是利用自定义的类加载器机制来完成模块化热部署 它实现的类加载机制就没有完全遵循自下而上的委托，有很多平级之间的类加载器查找.
	
		第四次： JDK9 引入模块系统之后，类加载器的实现其实做了一波更新
	
	在 JVM 中，类的唯一性是由类加载器实例和类的全限定名一同确定的
	
	
	
	
	